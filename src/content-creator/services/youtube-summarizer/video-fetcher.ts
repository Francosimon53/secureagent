/**
 * Content Creator Suite - YouTube Video Fetcher
 *
 * Fetches video metadata, transcripts, and captions from YouTube.
 */

import type { ServiceResult } from '../../types.js';
import type { YouTubeProvider, YouTubeVideoInfo, YouTubeTranscriptSegment, YouTubeChapter } from '../../providers/media/youtube.js';
import { CONTENT_EVENTS } from '../../constants.js';

// Local alias for compatibility
type YouTubeVideo = YouTubeVideoInfo;

// =============================================================================
// Types
// =============================================================================

export interface VideoFetchOptions {
  includeTranscript?: boolean;
  preferredLanguage?: string;
  includeChapters?: boolean;
  includeComments?: boolean;
  maxComments?: number;
}

export interface FetchedVideo {
  video: YouTubeVideo;
  transcript?: VideoTranscript;
  chapters?: VideoChapter[];
  comments?: VideoComment[];
  fetchedAt: number;
}

export interface VideoTranscript {
  text: string;
  segments: TranscriptSegment[];
  language: string;
  isAutoGenerated: boolean;
  duration: number;
}

export interface TranscriptSegment {
  text: string;
  startTime: number;
  endTime: number;
  duration: number;
}

export interface VideoChapter {
  title: string;
  startTime: number;
  endTime: number;
  thumbnailUrl?: string;
}

export interface VideoComment {
  id: string;
  text: string;
  author: string;
  authorChannelId?: string;
  likeCount: number;
  publishedAt: string;
  replies?: VideoComment[];
}

// =============================================================================
// Video Fetcher Service
// =============================================================================

export class VideoFetcherService {
  private eventHandlers: ((event: string, data: unknown) => void)[] = [];
  private cache = new Map<string, { data: FetchedVideo; expiresAt: number }>();
  private readonly cacheTTL = 30 * 60 * 1000; // 30 minutes

  constructor(private readonly youtubeProvider: YouTubeProvider) {}

  /**
   * Fetch a video with all requested data
   */
  async fetchVideo(
    videoId: string,
    options?: VideoFetchOptions
  ): Promise<ServiceResult<FetchedVideo>> {
    const opts = {
      includeTranscript: options?.includeTranscript ?? true,
      preferredLanguage: options?.preferredLanguage ?? 'en',
      includeChapters: options?.includeChapters ?? true,
      includeComments: options?.includeComments ?? false,
      maxComments: options?.maxComments ?? 50,
    };

    // Check cache
    const cacheKey = `${videoId}:${JSON.stringify(opts)}`;
    const cached = this.cache.get(cacheKey);
    if (cached && cached.expiresAt > Date.now()) {
      return { success: true, data: cached.data };
    }

    this.emit(CONTENT_EVENTS.YOUTUBE_SUMMARY_STARTED, { videoId, action: 'fetch' });

    try {
      // Fetch video metadata
      const videoResult = await this.youtubeProvider.getVideoInfo(videoId);
      if (!videoResult.success) {
        return videoResult;
      }

      const video = videoResult.data;
      const fetchedVideo: FetchedVideo = {
        video,
        fetchedAt: Date.now(),
      };

      // Fetch transcript if requested
      if (opts.includeTranscript) {
        const transcriptResult = await this.fetchTranscript(videoId, opts.preferredLanguage);
        if (transcriptResult.success) {
          fetchedVideo.transcript = transcriptResult.data;
        }
      }

      // Extract chapters from description if requested
      if (opts.includeChapters) {
        fetchedVideo.chapters = this.extractChapters(video);
      }

      // Fetch comments if requested
      if (opts.includeComments) {
        const commentsResult = await this.fetchComments(videoId, opts.maxComments);
        if (commentsResult.success) {
          fetchedVideo.comments = commentsResult.data;
        }
      }

      // Cache the result
      this.cache.set(cacheKey, {
        data: fetchedVideo,
        expiresAt: Date.now() + this.cacheTTL,
      });

      this.emit(CONTENT_EVENTS.YOUTUBE_SUMMARY_COMPLETED, {
        videoId,
        title: video.title,
        hasTranscript: !!fetchedVideo.transcript,
        chapterCount: fetchedVideo.chapters?.length ?? 0,
        action: 'fetch',
      });

      return { success: true, data: fetchedVideo };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to fetch video';
      this.emit(CONTENT_EVENTS.CONTENT_FAILED, { videoId, error: message, source: 'youtube' });
      return { success: false, error: message };
    }
  }

  /**
   * Fetch video transcript/captions
   */
  async fetchTranscript(
    videoId: string,
    preferredLanguage: string = 'en'
  ): Promise<ServiceResult<VideoTranscript>> {
    try {
      // Get transcript directly from YouTube
      const transcriptResult = await this.youtubeProvider.getTranscript(videoId, preferredLanguage);
      if (!transcriptResult.success) {
        return { success: false, error: transcriptResult.error };
      }

      const youtubeSegments = transcriptResult.data;
      if (youtubeSegments.length === 0) {
        return { success: false, error: 'No transcript segments available for this video' };
      }

      // Convert YouTube transcript segments to our format
      const segments: TranscriptSegment[] = youtubeSegments.map(seg => ({
        text: seg.text,
        startTime: seg.start,
        endTime: seg.start + seg.duration,
        duration: seg.duration,
      }));

      const fullText = segments.map(s => s.text).join(' ');
      const lastSegment = segments[segments.length - 1];

      const transcript: VideoTranscript = {
        text: fullText,
        segments,
        language: preferredLanguage,
        isAutoGenerated: true, // Can't determine from getTranscript
        duration: lastSegment ? lastSegment.endTime : 0,
      };

      return { success: true, data: transcript };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to fetch transcript';
      return { success: false, error: message };
    }
  }

  /**
   * Fetch video comments
   * Note: Comments API not currently implemented in YouTubeProvider
   */
  async fetchComments(
    _videoId: string,
    _maxComments: number = 50
  ): Promise<ServiceResult<VideoComment[]>> {
    // Comments API requires OAuth and is not implemented in the base YouTubeProvider
    return { success: false, error: 'Comments API not available' };
  }

  /**
   * Extract video ID from various URL formats
   */
  extractVideoId(url: string): string | null {
    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
      /^([a-zA-Z0-9_-]{11})$/,
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return match[1];
      }
    }

    return null;
  }

  /**
   * Batch fetch multiple videos
   */
  async fetchVideos(
    videoIds: string[],
    options?: VideoFetchOptions
  ): Promise<Map<string, ServiceResult<FetchedVideo>>> {
    const results = new Map<string, ServiceResult<FetchedVideo>>();

    // Process in batches to avoid rate limiting
    const batchSize = 5;
    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      const batchPromises = batch.map(async (videoId) => {
        const result = await this.fetchVideo(videoId, options);
        return { videoId, result };
      });

      const batchResults = await Promise.all(batchPromises);
      for (const { videoId, result } of batchResults) {
        results.set(videoId, result);
      }

      // Small delay between batches
      if (i + batchSize < videoIds.length) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    return results;
  }

  // ===========================================================================
  // Private Methods
  // ===========================================================================

  /**
   * Extract chapters from video description
   */
  private extractChapters(video: YouTubeVideo): VideoChapter[] {
    const chapters: VideoChapter[] = [];
    const description = video.description;

    // Pattern for timestamps in description: 0:00 Title or 00:00 Title or 0:00:00 Title
    const chapterPattern = /(?:^|\n)(\d{1,2}:)?(\d{1,2}):(\d{2})\s*[-–—]?\s*(.+?)(?=\n|$)/g;
    let match;

    while ((match = chapterPattern.exec(description)) !== null) {
      const hours = match[1] ? parseInt(match[1].replace(':', '')) : 0;
      const minutes = parseInt(match[2]);
      const seconds = parseInt(match[3]);
      const startTime = hours * 3600 + minutes * 60 + seconds;
      const title = match[4].trim();

      if (title && title.length > 0) {
        chapters.push({
          title,
          startTime,
          endTime: 0, // Will be set later
        });
      }
    }

    // Set end times based on next chapter or video duration
    for (let i = 0; i < chapters.length; i++) {
      if (i < chapters.length - 1) {
        chapters[i].endTime = chapters[i + 1].startTime;
      } else {
        chapters[i].endTime = video.duration;
      }
    }

    return chapters;
  }

  /**
   * Clear cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  // ===========================================================================
  // Event Handling
  // ===========================================================================

  /**
   * Register event handler
   */
  onEvent(handler: (event: string, data: unknown) => void): () => void {
    this.eventHandlers.push(handler);
    return () => {
      const index = this.eventHandlers.indexOf(handler);
      if (index > -1) {
        this.eventHandlers.splice(index, 1);
      }
    };
  }

  /**
   * Emit event
   */
  private emit(event: string, data: unknown): void {
    for (const handler of this.eventHandlers) {
      try {
        handler(event, data);
      } catch (error) {
        console.error(`Error in event handler for ${event}:`, error);
      }
    }
  }
}

// =============================================================================
// Factory Function
// =============================================================================

export function createVideoFetcher(
  youtubeProvider: YouTubeProvider
): VideoFetcherService {
  return new VideoFetcherService(youtubeProvider);
}
